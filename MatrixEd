#!/usr/bin/python3

"""
MatrixEd - An LED Matrix Editor
"""

import sys
import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)

from PyQt5.QtWidgets import (QMainWindow, QApplication, QWidget, QGridLayout, QPushButton, QSpinBox, QLabel, QAction, qApp, QSizePolicy, QColorDialog, QDoubleSpinBox, QInputDialog, QFileDialog, QMessageBox)
from PyQt5.QtCore import *
from PyQt5.QtGui import (QColor, QImage, QPainter)

### The underlying data store for a Frame is a QImage
class Frame(QImage):
    def __init__(self, x, y):
        super(Frame, self).__init__(x, y, QImage.Format_RGB32)
         
        # Fill the QImage with solid white
        self.fill(QColor(255, 255, 255, 255))

    # Set pixels from index
    def setPixelIdx(self, idx, value):
        y = int(idx / super(Frame, self).width())
        x = (idx - y)
        if (type(value) is QColor):
            super(Frame, self).setPixel(x, y, value.rgb())
        else:
            super(Frame, self).setPixel(x, y, value)

    # Set pixels directly
    def setPixel(self, x, y, value):
        if (type(value) is QColor):
            super(Frame, self).setPixel(x, y, value.rgb())
        else:
            super(Frame, self).setPixel(x, y, value)

    # Get pixels from an index
    def getPixelIdx(self, idx):
        y = int(idx / super(Frame, self).width())
        x = (idx - y * super(Frame, self).width())
        return QColor(super(Frame, self).pixel(x, y))

    # Get pixels directly
    def getPixel(self, x, y):
        return QColor(super(Frame, self).pixel(x, y))
    
### The script class for generating frames programatically
class Script():
    def __init__(self, x, y):
        # Size of the area -> scripts should be written for any size
        self.x = x
        self.y = y

        # Script to call
        self.script = self.Edge_scr

        # Number of frames in the script
        self.frames = (self.x - 1) * 2 + (self.y - 1) * 2

        # Is the animation done rendering?
        self.done = False

    # Report if we're done
    def isDone(self):
        return self.done

    # Start at 0,0 and move around the edge
    def Edge_scr(self, idx):
        print("Generating frame: ", str(idx))
        frame = Frame(self.x, self.y)
            
        # Figure out which edge we're on
        iterationIdx = idx % self.frames;
        
        for y in range(0, self.y):
            for x in range(0, self.x):
                # Default is black
                color = QColor(0, 0, 0, 255)
        
                # Top edge
                if (iterationIdx < self.x):
                    if ((y == 0) and (x == iterationIdx)):
                        color = QColor(255, 0, 0, 255)

                # Right edge
                elif (iterationIdx < ((self.x + self.y) - 1)):
                    if ((x == self.x - 1) and (y == (iterationIdx - self.x))):
                        color = QColor(255, 0, 0, 255)

                # Bottom edge
                elif (iterationIdx < ((2 * self.x + self.y) - 2)):
                    if (y == self.y - 1):
                        color = QColor(255, 0, 0, 255)

                # Left edge
                else:
                    if (x == 0):
                        color = QColor(255, 0, 0, 255)

                frame.setPixel(x, y, color.rgb())
        return frame
       
    def render(self, idx):
        # Reset the render status
        if (idx == 0):
            self.done = False

        # Using the frame #, render the frame
        frame = self.script(idx)

        if (idx == self.frames - 1):
            self.done = True
        
        return frame

### The widget for the button matrix
class QMatrix(QWidget):
    def __init__(self, parent = None):
        super(QMatrix, self).__init__(parent)
    
        self.x = 5
        self.y = 5
        self.frame = 0
        self.mode = "Operate"
        self.buttons = []

        # Create the new Frame
        self.frames = []

        # Enabled / disabled switch
        self.status = []

        # Script for generating frames
        self.script = None

        # Setting the layout
        self.grid = QGridLayout()
        
        # Create the initial grid
        self.regen()

        # Set the layout
        self.setLayout(self.grid)

    ### Set the X Dimension and regenerate the array
    def setX(self, x):
        self.x = x
        self.regen()

    ### Set the Y Dimension and regenerate the array
    def setY(self, y):
        self.y = y
        self.regen()

    ### Regenerate the array with the current parameters
    def regen(self):
        # Delete old push buttons
        for p in self.buttons:
            p.hide()
            p.deleteLater()
        self.buttons = []
        self.status = []
        self.script = None

        # Create new pushbuttons
        for y in range(0,self.y):
            for x in range(0,self.x):
                p = QPushButton(str(y * self.x + x))
                self.grid.addWidget(p, y, x, 1, 1)
                p.clicked.connect(lambda: self.push())
                p.setStyleSheet('border: 0px; background-color: white; color: white')
                self.buttons.append(p)
                self.status.append(True)
                
                sp = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
                sp.setHorizontalStretch(0)
                sp.setVerticalStretch(0)
                sp.setHeightForWidth(p.sizePolicy().hasHeightForWidth())
                p.setSizePolicy(sp)
        
        # Reset the frame
        self.frames = []
        self.frames.append(Frame(self.x, self.y))

    ### Behavior when pressing a matrix button
    def push(self):
        pb = self.sender()
        pbNum = int(pb.text())
        if (self.mode == "Layout"):
            if (self.status[pbNum] == True):
                pb.setStyleSheet('border: 0px; background-color: black; color: black')
                self.status[pbNum] = False
            else:
                pb.setStyleSheet('border: 0px; background-color: white; color: white')
                self.status[pbNum] = True
        else:
            color = QColorDialog.getColor()
            if (color.isValid()):
                pb.setStyleSheet('border: 0px; background-color: ' + color.name() + '; color: ' + color.name())
                self.frames[self.frame].setPixelIdx(pbNum, color)

    ### Switch the current operating mode
    def setMode(self):
        if (self.mode == "Layout"):
            self.mode = "Operate"

            # Disable the buttons that aren't operating
            for p in self.buttons:
                pbNum = int(p.text())
                if (self.status[pbNum] == False):
                    p.setEnabled(False)
                    p.setVisible(False)
                else:
                    p.setEnabled(True)
                    p.setVisible(True)

            # Propagate the changes to all of the frames
            for f in self.frames:
                f.status = self.status
        else:
            self.mode = "Layout"
            # Enable all of the buttons in layout mode to allow turning things on/off
            for p in self.buttons:
                p.setEnabled(True)
                p.setVisible(True)

    ### Move to the next frame
    def frameUp(self):
        # If we're not using a script, it's being handled manually
        # If we're done rendering the frames, don't re-render
        if ((self.script == None) or (self.script.isDone())):
            self.frame = self.frame + 1

            if (self.frame >= len(self.frames)):
                self.frame = 0
        
        # If we are using a script, generate the frame
        else:
            self.frame = self.frame + 1
            self.frames.append(self.script.render(self.frame))

        # Update the frame index
        self.parent().parent().updateFrameIndex(self.frame, len(self.frames))

        # Now update the loaded buttons
        self.updateMatrix()

    ### Move to the next frame
    def frameAdd(self):
        # Add the frame
        self.frames.append(Frame(self.x, self.y))

        # Set the frame to the new frame
        self.frame = len(self.frames) - 1

        # Update the frame index
        self.parent().parent().updateFrameIndex(self.frame, len(self.frames))

        # Now update the loaded buttons
        self.updateMatrix()

    ### Move to the previous frame
    def frameDown(self):
        self.frame = self.frame - 1

        # If we're below 0, loop back to the last frame
        if (self.frame < 0):
            self.frame = len(self.frames) - 1

        # Update the frame index
        self.parent().parent().updateFrameIndex(self.frame, len(self.frames))

        # Now update the loaded buttons
        self.updateMatrix()

    ### Update the button matrix from the currently loaded frame
    def updateMatrix(self):
        for idx in range(0, len(self.buttons)):
            pb = self.buttons[idx]
            if (self.status[idx]):
                color = self.frames[self.frame].getPixelIdx(idx)
                pb.setStyleSheet('border: 0px; background-color: ' + color.name() + '; color: ' + color.name())
            else:
                pb.setStyleSheet('border: 0px; background-color: black; color: black')

    ### Blit a QImage to the current frame
    def blit(self, qmg):
        dest = QPoint(0, 0)
        qp = QPainter(self.frames[self.frame])
        qp.drawImage(dest, qmg)
        qp.end()

        # Update the loaded buttons
        self.updateMatrix()

    ### Save a frame as an image file
    def saveFrame(self, fn):
        if (not self.frames[self.frame].save(fn)):
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Unable to save the frame!")
            msg.setStandardButtons(QMessageBox.Ok)
            msg.exec_()
    
    ### Set the script
    def setScript(self, scr):
        print("scr: ", scr)
        if (scr == "Edge"):
            print("Set script to EDGE")
            self.script = Script(self.x, self.y)

        # Generate frame 0
        self.frame = 0
        self.frames = [ self.script.render(0) ]

        # Update the loaded buttons
        self.updateMatrix()

class MatrixEd(QMainWindow):
    def __init__(self):
        super(QMainWindow, self).__init__()
        
        #############
        # Main Widget
        #############
        self.qw = QWidget()
        self.mainLayout = QGridLayout()
        
        # Build the box first so that we can set signals
        self.matrix = QMatrix()
        self.mainLayout.addWidget(self.matrix, 1, 0, 1, 4)

        # Play button and time between frames
        self.PlayButton = QPushButton("Play")
        self.PlayButton.clicked.connect(self.playBtn)
        self.mainLayout.addWidget(self.PlayButton, 0, 0, 1, 2)
        self.TimerBox = QDoubleSpinBox()
        self.TimerBox.setValue(1.0)
        self.TimerBox.setSingleStep(0.01)
        self.TimerBox.valueChanged.connect(self.updateTimerTickrate)
        self.mainLayout.addWidget(self.TimerBox, 0, 2)
        self.TimerBoxLabel = QLabel("Sec/Frame")
        self.mainLayout.addWidget(self.TimerBoxLabel, 0, 3)

        # Build the timer object
        self.Timer = QTimer()
        self.Timer.timeout.connect(self.timerTick)

        # Frame Left Button
        self.FrameLeft = QPushButton("<")
        self.FrameLeft.clicked.connect(self.matrix.frameDown)
        self.mainLayout.addWidget(self.FrameLeft, 2, 0)

        # Frame Index
        self.FrameIdx = QLabel("Frame: 1 of 1")
        self.mainLayout.addWidget(self.FrameIdx, 2, 1)

        # Frame Right Button
        self.FrameRight = QPushButton(">")
        self.FrameRight.clicked.connect(self.matrix.frameUp)
        self.mainLayout.addWidget(self.FrameRight, 2, 2)
        
        # Add Frame
        self.FrameAdd = QPushButton(">+")
        self.FrameAdd.clicked.connect(self.matrix.frameAdd)
        self.mainLayout.addWidget(self.FrameAdd, 2, 3)

        ##############
        # Top menu bar
        ##############
        self.menubar = self.menuBar()

        # File Menu
        self.newAction = QAction('&New', self)

        self.saveAction = QAction('&Save', self)
        
        self.loadAction = QAction('&Load', self)
        
        self.loadScriptAction = QAction('Load Script', self)
        self.loadScriptAction.triggered.connect(self.pickScript)

        self.exitAction = QAction('&Exit', self)
        self.exitAction.setShortcut('Ctrl+Q')
        self.exitAction.triggered.connect(qApp.quit)

        self.fileMenu = self.menubar.addMenu('&File')
        self.fileMenu.addAction(self.newAction)
        self.fileMenu.addAction(self.saveAction)
        self.fileMenu.addAction(self.loadAction)
        self.fileMenu.addAction(self.loadScriptAction)
        self.fileMenu.addAction(self.exitAction)

        # Layout Menu
        self.layoutAction = QAction('&Modify LED Layout Mode', self)
        self.layoutAction.setCheckable(True)
        self.layoutAction.triggered.connect(self.matrix.setMode)

        self.XDimAction = QAction('Set the X Dimension', self)
        self.XDimAction.triggered.connect(self.setXDim)

        self.YDimAction = QAction('Set the Y Dimension', self)
        self.YDimAction.triggered.connect(self.setYDim)
        
        self.layoutMenu = self.menubar.addMenu('&Layout')

        self.layoutMenu.addAction(self.layoutAction)
        self.layoutMenu.addAction(self.XDimAction)
        self.layoutMenu.addAction(self.YDimAction)


        # Content Menu
        self.importAction = QAction('Import Image as Current Frame', self)
        self.importAction.triggered.connect(self.ImportFrame)

        self.exportAction = QAction('Export Current Frame as Image', self)
        self.exportAction.triggered.connect(self.ExportFrame)

        self.contentMenu = self.menubar.addMenu('&Content')
        self.contentMenu.addAction(self.importAction)
        self.contentMenu.addAction(self.exportAction)

        # Help Menu
        self.helpAction = QAction('&Help', self)
        self.aboutAction = QAction('&About', self)

        self.helpMenu = self.menubar.addMenu('&Help')

        self.helpMenu.addAction(self.helpAction)
        self.helpMenu.addAction(self.aboutAction)

        #####################
        # Set the main layout
        #####################
        self.qw.setLayout(self.mainLayout)
        self.setCentralWidget(self.qw)
        
        # Set the tile
        self.setWindowTitle('MatrixEd')

        # Show the window
        self.show()
    
    ############################
    # Set the X Dimension dialog
    ############################
    def setXDim(self):
        x = -1
        while(x <= 0):
            x, ok = QInputDialog.getInt(self, 'Set the X Dimension', 'Enter the X Dimension:', self.matrix.x, 1)
        if (not (x == self.matrix.x)):
            self.matrix.setX(x)
    
    ############################
    # Set the Y Dimension dialog
    ############################
    def setYDim(self):
        self.qid = QInputDialog()
        y = -1
        while(y <= 0):
            y, ok = QInputDialog.getInt(self, 'Set the Y Dimension', 'Enter the Y Dimension:', self.matrix.y, 1)
        if (not (y == self.matrix.y)):
            self.matrix.setY(y)

    ########################
    # Update the frame index
    ########################
    def updateFrameIndex(self, idx, total):
        self.FrameIdx.setText("Frame: " + str(idx + 1) + " of " + str(total))
    
    ###############################
    # Start/stop the playback timer
    ###############################
    def playBtn(self):
        if (self.PlayButton.text() == "Play"):
            # Start the timer
            self.Timer.start(self.TimerBox.value() * 1000)
            
            # Set the name of the button to pause
            self.PlayButton.setText("Pause")
        else:
            # Stop the timer
            self.Timer.stop()

            # Update the button text
            self.PlayButton.setText("Play")
    
    #################################
    # Callback for the playback timer
    #################################
    def timerTick(self):
        # Move to the next frame 
        self.matrix.frameUp()
    
    ##########################################################
    # Callback for the playback timer's tickrate being changed
    ##########################################################
    def updateTimerTickrate(self):
        # If the timer is running, change it
        if (self.Timer.isActive):
            self.Timer.setInterval(self.TimerBox.value() * 1000)

    ##########################################################
    # Dialog for importing a frame
    ##########################################################
    def ImportFrame(self):
        fn, fm = QFileDialog.getOpenFileName(self, 'Open frame...', None, "Images (*.bmp *.gif *.jpg *.jpeg *.png);;All Files (*)")  
        if (fn != None):
            print (fn)
            img = QImage(fn)
            if (img != None):
                self.matrix.blit(img)

    ##########################################################
    # Dialog for exporting a frame
    ##########################################################
    def ExportFrame(self):
        fn, fm = QFileDialog.getSaveFileName(self, 'Save as...', None, "Images (*.bmp *.jpg *.jpeg *.png);;All Files (*)")
        if (fn != None):
            self.matrix.saveFrame(fn)
    
    ##########################################################
    # Dialog for picking a script
    ##########################################################
    def pickScript(self):
        script, ok = QInputDialog.getItem(self, 'Pick a script to generate the frames', 'Script:', ['Edge', 'Cylon'])
        if (ok):
            self.matrix.setScript(script)
    
    #####################
    # Key Press Handler
    #####################
    def keyPressEvent(self, e):
        if (e.key() == Qt.Key_Escape):
            self.close()
        if (e.key() == Qt.Key_Greater):
            self.matrix.frameUp()
        if (e.key() == Qt.Key_Less):
            self.matrix.frameDown()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    prog = MatrixEd()
    sys.exit(app.exec_())
